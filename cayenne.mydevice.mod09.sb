//******************************************************************************
// Copyright (c) 2017, Laird
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
// SPDX-License-Identifier:ISC
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filename    ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This app provides for a command interface over the uart and the protocol is
// as follows:-
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//******************************************************************************

//******************************************************************************
// Definitions
//******************************************************************************
#include "RM1xx-defs.h"

    //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1
    //Size of i[]

#define NUM_OF_I_PARAMS                     (4)
    //Size of s$[]     
#define NUM_OF_S_PARAMS                     (4)

    //Button1 : SIO4 is connected to the CS line via J18
#define SPI_CS_PIN  	4

    //SIO5 is connected to the temperature sensor
#define TEMP_SENS_PIN 	5
    
    //SIO28 is connected to Button2 with a jumper on DVK	
#define BUTTON2 		28

    //SIO6 is connected to LED5
#define LED5 			6

    //Set to 1 to automatically join the LoRa network at startup
#define AUTO_JOIN 		1

//******************************************************************************
// Register Error Handler as early as possible
//******************************************************************************
sub HandlerOnErr()
    print "\n OnErr - ";GetLastError();"\n"
endsub
onerror next HandlerOnErr

//******************************************************************************
// Debugging resource as early as possible
//******************************************************************************

//==============================================================================
//==============================================================================
sub AssertResCode(byval rc as integer,byval tag as integer)
    if rc!=0 then
        print "\nFailed with ";integer.h' rc;" at tag ";tag
    endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
    if (ENABLE_DEBUG_PRINTS!=0) then
        print "\n";msg$;" ";vl
    endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
    if (ENABLE_DEBUG_PRINTS!=0) then
        print "\n";msg$
    endif
endsub

//******************************************************************************
// Library Import
//******************************************************************************

//******************************************************************************
// Debugging resource after libs
//******************************************************************************

//******************************************************************************
// Global Variable Declarations
//******************************************************************************

dim rc
dim stRsp$ as string        //Uart rx data is stored here
dim str$

dim ok$,er$,pr$

dim i[NUM_OF_I_PARAMS]      // index 0 used for return values
dim s$[NUM_OF_S_PARAMS]    // values stored in NVRAM (AppEUI and DevAddr) are stored here

dim urtcmd$                 //cmd line from uart
dim tkn$,tlen               //used by command parser
dim urts                    //will be <0 if uart parser suspended

dim SPIHandle

dim led : led = 0			//led status
				
    //OTAA. To use ABP, replace the value with LORAMAC_JOIN_BY_PERSONALIZATION
dim nJoinType : nJoinType = LORAMAC_JOIN_BY_REQUEST		
//******************************************************************************
// initialize Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "\r\n>"

urts=0 //not suspended

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************
SUB PrintMsg(str$)
    rc = UartWrite(str$)
ENDSUB

//==============================================================================
sub UartRsp(rsp as integer)
    if rsp == 0 then
        print ok$;pr$
    elseif rsp > 0 then 
        print er$;integer.h' rsp;pr$
    endif
    urts = rsp
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
    while num>0
        tlen = ExtractIntToken(u$,i[stIdx])
        if tlen == 0 then
            exitfunc 4
        endif
        num=num-1
        stIdx = stIdx+1
    endwhile
endfunc 0

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ReadTemp()
    dim tempC : tempC = GpioRead(TEMP_SENS_PIN)
    tempC = ((19028992-36000*tempC)/11971)
endfunc tempC

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
sub EndianSwap(byref atm)
    atm = (atm >> 8 & 0xFF) | (atm << 8 & 0xFF00)
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ReadBtnState()
    dim wr$, rd$
    wr$="\41\09\00"
    GpioWrite(SPI_CS_PIN,0)
    rc=SpiReadWrite(wr$,rd$)
    GpioWrite(SPI_CS_PIN,1)
    // The GPIO pin status comes back in the 3rd byte
    rc=StrGetChr(rd$,2)
    // Check if IO4 is grounded
endfunc ((rc&0x10)==0)

function LoraPost()
    print "LoraPost()"
    dim tempType$, tempVal$,txData$, powerVal$, bttn1State$, led5State$
    dim atm 
	
	// 	LPP (Low Power Payload) for Cayenne - first byte is data channel and second byte is data type 
    tempType$="\01\67"		// "\67" : Temperature 
    atm = ReadTemp()
    EndianSwap(atm)

    rc=bleencode16(tempVal$,atm,0)

    powerVal$ = "\02\02"	// "\02" : Analog input
    atm = ReadPwrSupplyMv()/10
    EndianSwap(atm)
    rc=bleencode16(powerVal$,atm,2)
 
    atm = ReadBtnState()
    bttn1State$ = "\03\00"	// "\00" : Digital input 
    rc=bleencode8(bttn1State$,atm,2)

    led5State$ = "\04\01"	// "\01" : Digital output
	
    if (led == 0) then	
        rc=strsetchr(led5State$,0,2)
    else 
        rc=strsetchr(led5State$,1,2)
    endif
	
	txData$ = tempType$ + tempVal$ + powerVal$ + bttn1State$ + led5State$
	print "\ntxData$: ";txData$ 
	
    rc = LORAMACTxData(1, txData$, 1)
endfunc 1

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------

function _Lora()
    dim prAdr$ 
    dim val
    dim res
    dim reg
    dim stringVal$
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    elseif strcmp(tkn$,"join")==0 then
        exitfunc LORAMACJoin(LORAMAC_JOIN_BY_REQUEST)
    elseif strcmp(tkn$, "activate")==0 then
        exitfunc LORAMACJoin(LORAMAC_JOIN_BY_PERSONALIZATION)
    elseif strcmp(tkn$,"send")==0 then
        // #>lora send <data> <port> <confirm>
        rc = ExtractStrToken(urtcmd$, tkn$)
        rc = ExtractIntTokens(urtcmd$,1,2)
        exitfunc LORAMACTxData(i[1], tkn$, i[2])
    elseif strcmp(tkn$,"post")==0 then
        exitfunc LoraPost()
		// print "LoraPost()"
    // dim tempType$, tempVal$,txData$, powerVal$, bttn1State$, led5State$
    // dim atm 
	
	// // 	LPP (Low Power Payload) for Cayenne - first byte is data channel and second byte is data type 
    // tempType$="\01\67"		// "\67" : Temperature 
    // atm = ReadTemp()
    // EndianSwap(atm)

    // rc=bleencode16(tempVal$,atm,0)

    // powerVal$ = "\02\02"	// "\02" : Analog input
    // atm = ReadPwrSupplyMv()/10
    // EndianSwap(atm)
    // rc=bleencode16(powerVal$,atm,2)
 
    // atm = ReadBtnState()
    // bttn1State$ = "\03\00"	// "\00" : Digital input 
    // rc=bleencode8(bttn1State$,atm,2)

    // led5State$ = "\04\01"	// "\01" : Digital output
	
    // if (led == 0) then	
        // rc=strsetchr(led5State$,0,2)
    // else 
        // rc=strsetchr(led5State$,1,2)
    // endif
	
	// txData$ = tempType$ + tempVal$ + powerVal$ + bttn1State$ + led5State$
	// print "\ntxData$: ";txData$ 

    // exitfunc LORAMACTxData(1, txData$, 1)


		
    elseif strcmp(tkn$,"get")==0 then
        rc = ExtractIntToken(urtcmd$,reg)
        rc = LORAMACGetOption(reg, stringVal$)
        print stringVal$
        exitfunc rc
    elseif strcmp(tkn$,"set")==0 then
        rc = ExtractIntToken(urtcmd$,reg)
        rc = ExtractStrToken(urtcmd$,stringVal$)
        rc = LORAMACSetOption(reg, stringVal$)
        exitfunc rc
    elseif strcmp(tkn$,"debug")==0 then
        rc = ExtractIntTokens(urtcmd$,0,3)
        if rc == 0 then
            rc = LORAMACSetDebug(i[0],i[1],i[2])
        endif
        exitfunc rc
    endif
endfunc 5

//==============================================================================
function OnUartCmd() as integer
    dim inputVoltage_mV
    rc=1 //assume there is an error
    tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
    if tlen == 0 then
        rc=0
    elseif tlen > 0 then
        if strcmp(tkn$,"lora") == 0 then
            rc = _Lora()
        elseif strcmp(tkn$,"volts") == 0 then
            inputVoltage_mV = ReadPwrSupplyMv()
            print "Input voltage = ";inputVoltage_mV;"mV\n"
            rc=0
        elseif strcmp(tkn$,"exit") == 0 then
            rc=0
            exitfunc 0
        endif
    endif
    //Send a response back to the user
    UartRsp(rc)
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
    dim nMatch
    if urts < 0 then
        //uart parser is suspended
        exitfunc 1
    endif

    //check if CR has been received
    nMatch=UartReadMatch(stRsp$,13)
    if nMatch!=0 then
        //CR exists in the input buffer
        urtcmd$ = strsplitleft$(stRsp$,nMatch)
        exitfunc OnUartCmd()
    endif
endfunc 1

'//==============================================================================
'// This handler is called when there is a LoRa TX Complete event
'//==============================================================================
function HandlerLoRaTxComp() as integer
    print "\nLoRa TX Complete Event"
endfunc 1

'//==============================================================================
'// This handler is called when there is a LoRa RX Complete event
'//==============================================================================
function HandlerLoRaRxComp() as integer
    print "\nLoRa RX Complete Event"
endfunc 1

'//==============================================================================
'// This handler is called when the LoRa Join procedure starts
'//==============================================================================
function HandlerLoRaJoining() as integer
    print "\nAttempting to join the LoRa network"
endfunc 1

'//==============================================================================
'// This handler is called when there is a LoRa Join Success Complete event
'//==============================================================================
function HandlerLoRaJoined() as integer
    print "\nSuccessfully joined the LoRa network"
	
	//Change data rate to DR4 to allow bigger payload
	dim wr$ : wr$ = "4"
    rc = LORAMACSetOption(LORAMAC_OPT_DATA_RATE, wr$)
    
	if (AUTO_JOIN == 1) then	
        print "\nNow RM1xx will send data to Cayenne periodically"
        TimerStart(0, 10000, 1)
    endif
endfunc 1

'//==============================================================================
'// This handler is called when there is a LoRa Join Fail event
'//==============================================================================
function HandlerLoRaJoinFailed() as integer
    print "\nFailed to join the LoRa network"
endfunc 1

'//==============================================================================
'// This handler is called when there is a LoRa Tx Timeout event 
'//==============================================================================
function HandlerLoRaTxTimeout() as integer
    print "\nLoRa TX Timeout"
endfunc 1

'//==============================================================================
'// This handler is called when there is a LoRa Rx Timeout event
'//==============================================================================
function HandlerLoRaRxTimeout() as integer
    print "\nLoRa RX Timeout"
endfunc 1

'//==============================================================================
'// This handler is called when there is an error in the receive path
'//==============================================================================
function HandlerLoRaRxError() as integer
    print "\nLoRa RX Error"
endfunc 1

//==============================================================================
// This handler is called when the TxDone signal has been received in the module
//==============================================================================
function HandlerLoRaTxDone() As Integer
    str$ = "\nTx Done"
    PrintMsg(str$)
endfunc 1

//==============================================================================
// This handler is called an RxWindow has faied to revceive a sync pulse
//==============================================================================
function HandlerLoRaNoSync() As Integer
    str$ = "\nNo Sync pulse"
    PrintMsg(str$)
endfunc 1

//==============================================================================
// This handler is called when An ADR command has been receive as part of a downlink.
//==============================================================================
function HandlerLoRaAdr() As Integer
    str$ = "\nAdr received"
    PrintMsg(str$)
endfunc 1

//==============================================================================
// This handler is called when Button2 is pressed
//==============================================================================
function Button2Pressed()
    if (led == 0) then	
        gpiowrite(LED5,1)	//Turns LED5 on		
        led = 1
        print "\nButton2 pressed - LED5 turned on\n"
    else 	
        gpiowrite(LED5,0)	//Turns LED5 off
        led = 0
        print "\nButton2 pressed - LED5 turned off\n"
    endif	
endfunc 1

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
OnEvent  EVUARTRX             call  HandlerUartRxCmd
OnEvent  EVLORAMACTXCOMPLETE  call  HandlerLoRaTxComp
OnEvent  EVLORAMACRXCOMPLETE  call  HandlerLoRaRxComp
OnEvent  EVLORAMACJOINING     call  HandlerLoRaJoining
OnEvent  EVLORAMACJOINED      call  HandlerLoRaJoined
// OnEvent  EVLORAMACJOINFAIL  call  HandlerLoRaJoinFailed
OnEvent  EVLORAMACTXTIMEOUT   call  HandlerLoRaTxTimeout
OnEvent  EVLORAMACRXTIMEOUT   call  HandlerLoRaRxTimeout
OnEvent  EVLORAMACRXERROR     call  HandlerLoRaRxError
OnEvent  EVLORAMACTXDONE      call  HandlerLoRaTxDone
OnEvent  EVLORAMACNOSYNC      call  HandlerLoRaNoSync
OnEvent  EVLORAMACADR         call  HandlerLoRaAdr

OnEvent  EVTMR0 			  call	LoraPost		 
OnEvent  EVGPIOCHAN0 		  call  Button2Pressed

//------------------------------------------------------------------------------
// Initialise Services and then wait for events
//------------------------------------------------------------------------------

//==============================================================================
//==============================================================================
sub Initialise()
    //Set the temperature sensor up with 1/3 scaling
    rc = GpioSetFunc(TEMP_SENS_PIN, 3, 0x13)

    dim wr$ : wr$ = "4"

    //Automatically join the LoRa network if set
    if (AUTO_JOIN == 1) then
        rc = LORAMACJoin(nJoinType)
    endif

    //Setting for Button1
    rc=GpioSetFunc(SPI_CS_PIN, 2, 1)
    GpioWrite(SPI_CS_PIN, 1)
    rc=SpiOpen(0, 125000, 0, SPIHandle)
    wr$="\40\00\10"
    GpioWrite(SPI_CS_PIN, 0)
    rc=SpiWrite(wr$)
    GpioWrite(SPI_CS_PIN, 1)
    // Enable a weak pull-up on the push button (GPPU 0x06)
    wr$="\40\06\10"
    GpioWrite(SPI_CS_PIN, 0)
    rc=SpiWrite(wr$)
    GpioWrite(SPI_CS_PIN, 1)
	
    //Set LED5 as GIDITAL_OUT with initial output low
    rc = gpiosetfunc(LED5,2,0)
    //Setting BUTTON2 as Digial_IN with weak pull-up
    rc = gpiosetfunc(BUTTON2,1,2)
    //Link Button2 to LED5
    rc = GpioBindEvent(0, BUTTON2 ,1)	//Binds a gpio transition high to an event. 
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()

//Send an OK response
UartRsp(0)

rc = LORAMACSetDebug(1,4,5)

//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent
